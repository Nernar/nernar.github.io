# Калбеки

От словосочетания вызов + обратно, именно с помощью них мы и будем осуществлять регистрацию обработчиков событий. Как и следует из названия, мы получим вызов, а после сможем отменить дальнейшее действие. Впрочем, не все действия можно отменить, а те которые можно могут быть отменены как другим модом, так и движком. Но остановимся на обработке калбеков.

## Регистрация обработчика

Для события производится с помощью метода [Callback.addCallback](/api/Callback/addCallback):

<Tabs groupId="scripting-language">
<TabItem value="js" label="JavaScript">

```js
Callback.addCallback("НазваниеСобытия", function(/* его аргументы */) {
    // действие которое будет вызвано вследствии события
}, 0 /* приоритет */);
```

</TabItem>
<TabItem value="ts" label="TypeScript">

```ts
Callback.addCallback("НазваниеСобытия", (/* его аргументы */) => {
    // действие которое будет вызвано вследствии события
}, 0 /* приоритет */);
```

</TabItem>
</Tabs>

Указание аргументов для события опционально, для всех действий в результате событий приходит одинаковое количество аргументов. Если событие поддерживает отмену действия, вы можете воспользоваться [Game.prevent](/api/Game/prevent), а также проверить было ли оно уже отменено с помощью [Game.isActionPrevented](/api/Game/isActionPrevented).

Приоритет определяет порядок выполнения событий. Чем он больше, тем раньше других будет вызван ваш обработчик. Не указывайте слишком большие числа, ограничьтесь, скажем, 10. Если приоритет не указан, будет использоваться стандартный (0).

:::danger Не добавляйте калбек с помощью события

В противном случае, новое действие калбека будет дублироваться вместе с каждым вызовом события.

:::

Вы можете провести эксперимент с одним из существующих примеров в [Callback](/api/Callback/addCallback), там приведен полный список игровых событий на текущий момент.

## Вызов своих событий

Производится с помощью метода [Callback.invokeCallback](/api/Callback/invokeCallback). Общий синтаксис весьма прост:

```js
Callback.invokeCallback("НазваниеСобытия", /* аргументы, которые будут переданы в событие */); 
```

Общее количество аргументов для передачи может быть не более 10. Ни в коем случае не вызывайте игровые события таким образом! Выделите необходимую часть кода в отдельную функцию или собственное событие при необходимости.

## Знакомство с миром событий

В качестве простого примера, можно вывести `Привет, Мир!` с помощью регистрации обработчика на новое событие и его последующего вызова. Дополним код выше:

<Tabs groupId="scripting-language">
<TabItem value="js" label="JavaScript">

```js
Callback.addCallback("MyMod:HelloWorld", function(who) {
    alert("Привет, " + who + "!");
});
Callback.invokeCallback("MyMod:HelloWorld", "Мир");
```

</TabItem>
<TabItem value="ts" label="TypeScript">

```ts
Callback.addCallback("MyMod:HelloWorld", who => alert(`Привет, ${who}!`));
Callback.invokeCallback("MyMod:HelloWorld", "Мир");
```

</TabItem>
</Tabs>

Замените *Мир*, скажем, на свое имя.

## Какие события бывают

Мы вернулись к тому, с чего начали. Именно калбеки реализуют использование событий, на этот раз пройдем каждую из категорий с помощью кода их использования. Для получения более подробной информации о списке аргументов определенного калбека воспользуйтесь сводкой, либо просто продолжайте изучение документации. Мы неоднократно затронем большинство событий на практике.

### Строительства и разрушения

Являются основными событиями блоков и тайлов. С их помощью мы можем заменять дроп, выпадаемый из блоков, разрушать инструменты вследствии этого, развивать навыки, следить за обновлениями блоков и не только.

### Взаимодействия с миром

Сюда входят как использование предметов, так и взаимодействие с блоками, тайлами и существами. Сюда входят использование удочки, поедание чего-либо, броски снежков, открытие контейнеров, попадание стрелы в блок или существо и прочее.

### Существ и игрока

Существа превносят свои собственные события, начиная от их добавления в мир, получением урона, поднятием предметов, изменением опыта в случае игрока и их последующим деспавном или убийством.

### Измерений и мира

В том числе перемещение между измерениями, взрывы, использование редстоуна, генерации новых чанков, выбрасывания предметов из раздатчика и прочих событий, касающихся мира и его окружения.

### Интерфейсные

Изменение окон с открытием и закрытием, открытие контейнеров, перенос предметов между слотами, выбор самих слотов, крафтинг, изменение иконок предметов и похожее.

### Серверные и внутренние

Для обнаружения присоединения новых игроков, чтения и записи сохранений, нажатия клавиш устройства, выхода и выбора мира, команд, событий загрузки, тиков игроков и сервера, и многого другого.

## Гарантии и требования

1. Прежде чем действие в следствии события будет обработано, все события, зарегистрированные на это действие, должны быть завершены.

    Это означает, что вы не должны осуществлять большую нагрузку во время события. В противном случае, если хотя бы пару модов будут совершать нагрузку, пользователь начнет различать подвисания и откажется от игры с вашим модом.

    Исключениями на этот случай являются открытие интерфейса или операции, которые видит сам пользователь, понимая, что все работает точно так как и планировалось.

2. Все действия, зарегистрированные на событие, выполняются последовательно.

    И в порядке добавления событий с помощью [Callback.addCallback](/api/Callback/addCallback), включая приоритеты.

3. Ограничтесь одной функцией для одного события.

    У вас возникнет необходимость использования нескольких проверок для обнаружения события. Мододелы постоянно не учитывают, что совместно с их модом может быть установлен еще десяток-другой.

    Выделите отдельный файл исключительно для событий. Выносите все необходимые условия в одну функцию. Поверьте опыту, это улучшит производительность.

4. Тик и некоторые виды таймеров не асинхронны с игрой.

    В первую очередь для обеспечения более стабильной работы, однако это может сыграть с вами злую шутку. Например, размещение большого количества блоков за один тик будет означать их постепенную отрисовку в мире, а не мгновенную установку как можно было ожидать.

    В зависимости от мощности устройства, это может привести как к лагам, так и к вылету. Выходом из этой ситуации будет подразделение работы в тике или переход на другие типы событий, конечно, если такое возможно.

    Однако, гарантируется, что время в игре и время тика будут практически идентичны в любой момент времени.

5. Делайте более простые проверки перед созданием нагрузки.

    Например, в случае взаимодействия с блоком, сначала проверяйте что это именно тот блок который вам нужен из переданных аргументов события, а уже после, обращайтесь к дополнительным методам.

:::note И помните

Только от вас зависит производительность игры. Мы, в свою очередь, делаем максимум чтобы направить вас на использование правильных инструментов и, как разработчики, обеспечиваем стабильную работу модифицированного клиента.

:::
